/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/db": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about all available databases
         * @description Get information about the database, including the names of all other available databases.
         *     Most API endpoints support specifying the databases to use for index and user data
         *     through the `index_db` and `user_data_db` query parameters.
         *     Regardless of which database is currently being defaulted to by panoptikon,
         *     the API allows you to perform actions and query data from any of the available databases.
         *     The current databases are simply the ones that are used by default.
         */
        get: operations["get_db_info_api_db_get"];
        put?: never;
        /**
         * Create new databases
         * @description Create new databases with the specified names.
         *     It runs the migration scripts on the provided database names.
         *     If the databases already exist, the effect is the same as running the migrations.
         */
        post: operations["create_db_api_db_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/open/file/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Open a file in the default application
         * @description Open a file in the default application on the host system.
         *     This is done using os.startfile on Windows and xdg-open on Linux.
         *     This is a potentially dangerous operation, as it can execute arbitrary code.
         */
        post: operations["open_file_on_host_api_open_file__sha256__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/open/folder/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Show a file in the host system's file manager
         * @description Show a file in the host system's file manager.
         *     This is done using the appropriate command for the host system.
         *     On Windows, the file is highlighted in the Windows Explorer.
         *     On macOS, the file is revealed in the Finder.
         *     This is a potentially dangerous operation.
         */
        post: operations["show_in_file_manager_api_open_folder__sha256__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/pql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search for files and items in the database
         * @description Search for files in the database based on the provided query parameters.
         *     This endpoint is meant to be used with the Panoptikon Query Language.
         */
        post: operations["pql_api_search_pql_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get statistics on the searchable data
         * @description Get statistics on the data indexed in the database.
         *     This includes information about the tag namespaces, bookmark namespaces, file types, and folders present.
         *     Most importantly, it includes the list of currently existing setters for each data type.
         *     This information is relevant for building search queries.
         */
        get: operations["get_stats_api_search_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/tags/top": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the most common tags in the database
         * @description Get the most common tags in the database, based on the provided query parameters.
         *     The result is a list of tuples, where each tuple contains the namespace, tag name,
         *     occurrences count, and relative frequency % (occurrences / total item_setter pairs).
         *     The latter value is expressed as a float between 0 and 1.
         *     The tags are returned in descending order of frequency.
         *     The `limit` parameter can be used to control the number of tags to return.
         *     The `namespace` parameter can be used to restrict the search to a specific tag namespace.
         *     The `setters` parameter can be used to restrict the search to specific setters.
         *     The `confidence_threshold` parameter can be used to filter tags based on the minimum confidence threshold.
         */
        get: operations["get_top_tags_api_search_tags_top_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search tag names for autocompletion
         * @description Given a string, finds tags whose names contain the string.
         *     Meant to be used for autocompletion in the search bar.
         *     The `limit` parameter can be used to control the number of tags to return.
         *     Returns a list of tuples, where each tuple contains the namespace, name,
         *     and the number of unique items tagged with the tag.
         *     The tags are returned in descending order of the number of items tagged.
         */
        get: operations["get_tags_api_search_tags_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/item/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from its sha256 hash
         * @description Returns metadata for a given item by its sha256 hash.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         *
         *     An `item` is a unique file. `item`s can have multiple `file`s associated with them, but unlike `file`s, `item`s have a unique sha256 hash.
         *     Files are unique by `path`. If all files associated with an `item` are deleted, the item is deleted.
         */
        get: operations["get_item_by_sha256_api_items_item__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/from-id/{item_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from its item_id
         * @description Returns metadata for a given item by its item_id.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         *
         *     An `item` is a unique file. `item`s can have multiple `file`s associated with them, but unlike `file`s, `item`s have a unique sha256 hash.
         *     Files are unique by `path`. If all files associated with an `item` are deleted, the item is deleted.
         */
        get: operations["get_item_by_id_api_items_from_id__item_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/from-file-id/{file_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from a file_id
         * @description Returns metadata for a given item by the file_id of one of its files.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         *
         *     An `item` is a unique file. `item`s can have multiple `file`s associated with them, but unlike `file`s, `item`s have a unique sha256 hash.
         *     Files are unique by `path`. If all files associated with an `item` are deleted, the item is deleted.
         */
        get: operations["get_item_by_file_id_api_items_from_file_id__file_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/from-path/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from a path
         * @description Returns metadata for a given item from its original file path.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         */
        get: operations["get_item_by_path_api_items_from_path__path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/file/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file by sha256
         * @description Returns the actual file contents for a given sha256 hash.
         *     Content type is determined by the file extension.
         */
        get: operations["get_file_by_sha256_api_items_file__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/thumbnail/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get thumbnail for an item by its sha256
         * @description Returns a thumbnail for a given item by its sha256 hash.
         *     The thumbnail may be a thumbnail,
         *     the unmodified original image (only for images),
         *     or a placeholder image generated on the fly.
         *     GIFs are always returned as the original file.
         *     For video thumbnails, the `big` parameter can be used to
         *     select between the 2x2 frame grid (big=True) or the first frame from the grid (big=False).
         */
        get: operations["get_thumbnail_by_sha256_api_items_thumbnail__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/text/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get text extracted from an item by its sha256
         * @description Returns the text extracted from a given item by its sha256 hash.
         */
        get: operations["get_text_by_sha256_api_items_text__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/text": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get text from text_ids
         * @description Returns texts given a list of text IDs.
         */
        get: operations["get_texts_by_text_ids_api_items_text_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/tags/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tags for an item by its sha256
         * @description Returns the tags associated with a given item by its sha256 hash.
         *     The response contains a list of tuples, where each tuple contains
         *     the tag namespace, tag name, confidence, and setter name.
         *     The `setters` parameter can be used to filter tags by the setter name.
         *     The `confidence_threshold` parameter can be used to filter tags based on
         *     the minimum confidence threshold
         */
        get: operations["get_tags_by_sha256_api_items_tags__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all bookmark namespaces */
        get: operations["get_ns_list_api_bookmarks_ns_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all users with bookmarks */
        get: operations["get_user_list_api_bookmarks_users_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns/{namespace}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all bookmarks in a namespace
         * @description Get all items bookmarked in namespace.
         *     Note that unlike the search API, this returns unique items, not files.
         *     This has two implications:
         *     1. Results are unique by `sha256` value.
         *     2. Even if multiple files have the same `sha256` value, they will only appear once in the results, with the path of the first reachable file found.
         *
         *     The `order_by` parameter can be used to sort the results by `last_modified`, `path`, or `time_added`.
         *     The `order` parameter can be used to sort the results in ascending or descending order.
         *     The `include_wildcard` parameter can be used to include bookmarks with the `*` user value.
         */
        get: operations["get_bookmarks_by_namespace_api_bookmarks_ns__namespace__get"];
        put?: never;
        /**
         * Add multiple bookmarks to a namespace
         * @description Add multiple bookmarks to a namespace.
         *     The `sha256` values of the items to be bookmarked should be provided in the request body.
         *     Optionally, metadata can be provided.
         *     If metadata is provided, it should be a dictionary where the keys are the `sha256`
         *     values and the values are dictionaries of metadata.
         *     If the sha256 value is not in the metadata dictionary keys, the entire metadata dictionary
         *     will be used as metadata for the the sha256 item.
         *     You can use this to set the same metadata for all items.
         *
         *     Example request body:
         *     ```
         *     {
         *         "sha256": ["<sha256_1>", "<sha256_2>", ...],
         *         "metadata": {
         *             "<sha256_1>: {
         *                 "key1": "value1",
         *                 "key2": "value2",
         *                 ...
         *             },
         *             "key1": "value1",
         *             "key2": "value2",
         *             ...
         *         }
         *     }
         *     ```
         */
        post: operations["add_bookmarks_by_sha256_api_bookmarks_ns__namespace__post"];
        /**
         * Delete all/many bookmarks in a namespace
         * @description Delete all bookmarks in a namespace. If `exclude_last_n` is provided, the last `n` added bookmarks will be kept.
         *     Alternatively, a list of `sha256` values can be provided in the request body to only delete specific bookmarks.
         */
        delete: operations["delete_bookmarks_by_namespace_api_bookmarks_ns__namespace__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns/{namespace}/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a bookmark by namespace and sha256
         * @description Get a bookmark by namespace and sha256.
         *     Returns whether the bookmark exists and the metadata.
         */
        get: operations["get_bookmark_api_bookmarks_ns__namespace___sha256__get"];
        /**
         * Add a bookmark by namespace and sha256
         * @description Add a bookmark by namespace and sha256.
         *     Optionally, metadata can be provided as the request body.
         *     Metadata should be a dictionary of key-value pairs.
         */
        put: operations["add_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__put"];
        post?: never;
        /** Delete a specific bookmark by namespace and sha256 */
        delete: operations["delete_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/item/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all bookmarks for an item
         * @description Get all bookmarks for an item.
         *     Returns a list of namespaces and metadata for each bookmark.
         */
        get: operations["get_bookmarks_for_item_api_bookmarks_item__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/predict/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run batch inference on a model by its `inference_id`
         * @description Runs batch inference on a model by its `inference_id` with the given inputs.
         *
         *     Before inference, the model is loaded using the specified `cache_key`, LRU size, and TTL (in seconds).
         *     This is identical to calling `PUT /load/{group}/{inference_id}`, see the documentation on that endpoint for more details.
         *
         *     Binary inputs are provided as multipart form data, structured inputs as JSON, the JSON string must be in the `data` form field.
         *     The JSON in the data field must be an object with an `inputs` key containing an array with the number of elements matching the size of the batch.
         *     Each element in the array can be a string, a dictionary, or null (in case that batch element only has binary input).
         *
         *     A batch consists of multiple inputs, each of which can be a binary file or a structured input or both.
         *     Binary files are mapped to the structured input by their filename which must be an index corresponding to the index of a structured input in the JSON array.
         *     The exact format depends on the specific model being used.
         *     The output can be either a JSON object containing an array under the key "outputs", a multipart/mixed response for binary data,
         *     or a single application/octet-stream for a single binary output.
         *
         *     Binary outputs are usually embeddings, which are provided in the npy format and can be loaded with numpy.load.
         *
         *     See `inferio.client` for an example of how to use this endpoint, which is non-trivial due to the multipart form data input and output.
         */
        post: operations["predict_api_inference_predict__group___inference_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/load/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Ensure a model is loaded into memory
         * @description Loads a model into memory with the specified `cache_key`, LRU size, and TTL (in seconds).
         *     As long as the model is present in at least one LRU cache, it will be kept in memory.
         *
         *     Models are evicted from an LRU in four cases:
         *
         *     - The LRU's size is exceeded when another load is attempted, causing the least recently used model(s) to be evicted
         *     - The model's TTL expires
         *     - The LRU is explicitly cleared by `cache_key` (see DELETE /cache/{cache_key})
         *     - The model is explicitly removed from the LRU (see DELETE /cache/{cache_key}/{group}/{inference_id})
         *
         *     The model will be loaded into memory only if it is not already loaded.
         *     If the model is already loaded, the cache key, LRU size, and TTL will be updated.
         *     The LRU size is overridden any time a load request is made, which may evict models from the LRU when it is resized.
         *
         *     A TTL of -1 means the model will never be unloaded due to TTL expiration. Other conditions still apply.
         */
        put: operations["load_model_api_inference_load__group___inference_id__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache/{cache_key}/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unload a model from memory
         * @description Removes a model from the LRU cache `cache_key`.
         *     Once a model is removed from all caches, it will be unloaded from memory.
         */
        delete: operations["unload_model_api_inference_cache__cache_key___group___inference_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache/{cache_key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear the cache
         * @description Clears the LRU cache with key `cache_key`.
         *     If the models in it are not referenced by any other cache, they will be unloaded from memory.
         */
        delete: operations["clear_cache_api_inference_cache__cache_key__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the list of loaded models
         * @description Returns a mapping of `inference_id`s for all loaded models to the lists of `cache_key`s that reference them.
         */
        get: operations["get_cached_models_api_inference_cache_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a mapping of all available models and their metadata
         * @description Returns metadata for all available `inference_id`s, divided by group.
         */
        get: operations["get_metadata_api_inference_metadata_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/queue": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get running job and queue status */
        get: operations["get_queue_status_api_jobs_queue_get"];
        put?: never;
        post?: never;
        /** Cancel queued jobs */
        delete: operations["cancel_queued_jobs_api_jobs_queue_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/data/extraction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Run a data extraction job */
        post: operations["enqueue_data_extraction_job_api_jobs_data_extraction_post"];
        /** Delete extracted data */
        delete: operations["enqueue_delete_extracted_data_api_jobs_data_extraction_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/folders/rescan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Run a folder rescan */
        post: operations["enqueue_folder_rescan_api_jobs_folders_rescan_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the current folder lists */
        get: operations["get_folders_api_jobs_folders_get"];
        /** Update the folder lists */
        put: operations["enqueue_update_folders_api_jobs_folders_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel the currently running job */
        post: operations["cancel_current_job_api_jobs_cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/folders/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the scan history */
        get: operations["get_scan_history_api_jobs_folders_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/data/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the extraction history */
        get: operations["get_extraction_history_api_jobs_data_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/jobs/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the current system configuration */
        get: operations["get_config_api_jobs_config_get"];
        /** Update the system configuration */
        put: operations["update_config_api_jobs_config_put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Root */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search */
        get: operations["search_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Scan */
        get: operations["scan_scan_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** APISearchStats */
        APISearchStats: {
            /** Setters */
            setters: [
                "tags" | "text" | "clip" | "text-embedding",
                string
            ][];
            /** Bookmarks */
            bookmarks: string[];
            files: components["schemas"]["FileStats"];
            tags: components["schemas"]["TagStats"];
            /** Folders */
            folders: string[];
            text_stats: components["schemas"]["ExtractedTextStats"];
        };
        /** AndOperator */
        AndOperator: {
            /** And  */
            and_: (components["schemas"]["SimilarTo"] | components["schemas"]["InBookmarks"] | components["schemas"]["MatchPath"] | components["schemas"]["MatchText"] | components["schemas"]["SemanticTextSearch"] | components["schemas"]["SemanticImageSearch"] | components["schemas"]["MatchTags"] | components["schemas"]["HasDataFrom"] | components["schemas"]["HasUnprocessedData"] | components["schemas"]["Match"] | components["schemas"]["AndOperator"] | components["schemas"]["OrOperator"] | components["schemas"]["NotOperator"])[];
        };
        /** Body_predict_api_inference_predict__group___inference_id__post */
        Body_predict_api_inference_predict__group___inference_id__post: {
            /**
             * Data
             * @description
             *     A JSON string containing the list of inputs to the batch prediction function, with the following structure:
             *     ```json
             *     {
             *         "inputs": [
             *             {"input2": "value"},
             *             null,
             *             ...
             *         ]
             *     }
             *     ```
             *     The array must have the same length as the number of inputs in the batch.
             *     This means that each file you include in the request must have a corresponding entry in the array.
             *     Entries can be JSON objects or null. For example, text embeddings expect objects with the following structure:
             *     ```json
             *     {
             *         "inputs": [
             *             {"text": "This is a sentence."},
             *             {"text": "Another sentence."},
             *             ...
             *         ]
             *     }
             *     ```
             *     For some models, the inputs can be null, in which case the corresponding file will be the only input.
             *
             *     Often, when not required, the input object will be used to pass optional inference-time parameters, such as "confidence" for confidence thresholds.
             *     In that case, null would result in default values being used.
             *
             *     Filenames for files in the files parameter must be integers starting from 0, representing the index in the batch, matching an element in the `inputs` array.
             *
             */
            data: string;
            /**
             * Files
             * @description
             *     A list of binary files to include in the batch prediction.
             *     Each file must have a filename that is an integer starting from 0, representing the index in the batch, matching an element in the `inputs` array in the `data` field.
             *     Files may be optional depending on the model, some do not operate on binary data.
             *
             * @default []
             */
            files: string[];
        };
        /** BookmarkMetadata */
        BookmarkMetadata: {
            /** Exists */
            exists: boolean;
            /** Namespace */
            namespace?: string | null;
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** BookmarkNamespaces */
        BookmarkNamespaces: {
            /** Namespaces */
            namespaces: string[];
        };
        /** BookmarkUsers */
        BookmarkUsers: {
            /** Users */
            users: string[];
        };
        /** CacheListResponse */
        CacheListResponse: {
            /** Cache */
            cache: {
                [key: string]: string[];
            };
        };
        /** CancelResponse */
        CancelResponse: {
            /** Detail */
            detail: string;
        };
        /** DBCreateResponse */
        DBCreateResponse: {
            /** Index Db */
            index_db: string;
            /** User Data Db */
            user_data_db: string;
        };
        /** DBInfo */
        DBInfo: {
            index: components["schemas"]["SingleDBInfo"];
            user_data: components["schemas"]["SingleDBInfo"];
        };
        /** DerivedDataArgs */
        DerivedDataArgs: {
            /** Name of the setter that would produce the derived data */
            setter_name: string;
            /** Data types that the associated data must have */
            data_types: string[];
        };
        /** EmbedArgs */
        EmbedArgs: {
            /**
             * Cache Key
             * @description The cache key to use for the inference *model*
             * @default search
             */
            cache_key: string;
            /**
             * LRU Cache Size
             * @description The size of the LRU cache to use for the inference *model*
             * @default 1
             */
            lru_size: number;
            /**
             * TTL Seconds
             * @description The time-to-live in seconds for the inference *model* to be kept in memory
             * @default 60
             */
            ttl_seconds: number;
        };
        /** ExistingBookmarkMetadata */
        ExistingBookmarkMetadata: {
            /** Namespace */
            namespace?: string | null;
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** ExtractedText */
        ExtractedText: {
            /** Id */
            id: number;
            /** Item Sha256 */
            item_sha256: string;
            /** Setter Name */
            setter_name: string;
            /** Language */
            language: string;
            /** Language Confidence */
            language_confidence: number | null;
            /** Text */
            text: string;
            /** Confidence */
            confidence: number | null;
            /** Length */
            length: number;
        };
        /** ExtractedTextStats */
        ExtractedTextStats: {
            /** Lowest Confidence */
            lowest_confidence?: number | null;
            /** Lowest Language Confidence */
            lowest_language_confidence?: number | null;
            /** Languages */
            languages?: string[];
        };
        /** FileRecord */
        FileRecord: {
            /** Id */
            id: number;
            /** Sha256 */
            sha256: string;
            /** Path */
            path: string;
            /** Last Modified */
            last_modified: string;
            /**
             * Filename
             * @default
             */
            filename: string;
        };
        /** FileScanRecord */
        FileScanRecord: {
            /** Id */
            id: number;
            /** Start Time */
            start_time: string;
            /** End Time */
            end_time: string;
            /** Path */
            path: string;
            /** Total Available */
            total_available: number;
            /** New Items */
            new_items: number;
            /** Unchanged Files */
            unchanged_files: number;
            /** New Files */
            new_files: number;
            /** Modified Files */
            modified_files: number;
            /** Marked Unavailable */
            marked_unavailable: number;
            /** Errors */
            errors: number;
            /** False Changes */
            false_changes: number;
            /** Metadata Time */
            metadata_time: number;
            /** Hashing Time */
            hashing_time: number;
            /** Thumbgen Time */
            thumbgen_time: number;
        };
        /** FileSearchResponse */
        FileSearchResponse: {
            /** Count */
            count: number;
            /** Results */
            results: components["schemas"]["SearchResult"][];
        };
        /** FileSearchResult */
        FileSearchResult: {
            /** Path */
            path: string;
            /** Sha256 */
            sha256: string;
            /** Last Modified */
            last_modified: string;
            /** Type */
            type: string;
        };
        /** FileStats */
        FileStats: {
            /** Total */
            total: number;
            /** Unique */
            unique: number;
            /** Mime Types */
            mime_types: string[];
        };
        /** Folders */
        Folders: {
            /** Included Folders */
            included_folders: string[];
            /** Excluded Folders */
            excluded_folders: string[];
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** HasDataFrom */
        HasDataFrom: {
            /** Item must have item_data produced by the given setter name */
            has_data_from: string;
        };
        /** HasUnprocessedData */
        HasUnprocessedData: {
            /** Item must have item_data of given types that has not been processed by the given setter name */
            has_data_unprocessed: components["schemas"]["DerivedDataArgs"];
        };
        /** InBookmarks */
        InBookmarks: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default false
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default desc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default desc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Restrict search to Bookmarks
             * @description Only include items that are bookmarked.
             */
            in_bookmarks: components["schemas"]["InBookmarksArgs"];
        };
        /** InBookmarksArgs */
        InBookmarksArgs: {
            /**
             * Enable the filter
             * @description
             *     Must be set to True, this option only exists to make sure the filter is not empty,
             *     given that that all fields are optional.
             *
             * @default true
             */
            filter: boolean;
            /**
             * Bookmark Namespaces
             * @description
             *     List of bookmark namespaces to filter by. If sub_ns is set to True, the filter will also
             *     include all sub-namespaces of the given namespaces (ie, namespace.*).
             *     If empty, all bookmarks will be included.
             *
             */
            namespaces?: string[];
            /**
             * Include Sub-namespaces
             * @description Include all sub-namespaces of the given namespaces (namespace.*).
             * @default false
             */
            sub_ns: boolean;
            /**
             * User
             * @default user
             */
            user: string;
            /**
             * Include Wildcard User
             * @description Include bookmarks set to the wildcard user ('*').
             * @default true
             */
            include_wildcard: boolean;
        };
        /** ItemBookmarks */
        ItemBookmarks: {
            /** Bookmarks */
            bookmarks: components["schemas"]["ExistingBookmarkMetadata"][];
        };
        /** ItemMetadata */
        ItemMetadata: {
            item: components["schemas"]["ItemRecord"];
            /** Files */
            files: components["schemas"]["FileRecord"][];
        };
        /** ItemRecord */
        ItemRecord: {
            /** Id */
            id: number;
            /** Sha256 */
            sha256: string;
            /** Md5 */
            md5: string;
            /** Type */
            type: string;
            /** Size */
            size: number | null;
            /** Width */
            width: number | null;
            /** Height */
            height: number | null;
            /** Duration */
            duration: number | null;
            /** Audio Tracks */
            audio_tracks: number | null;
            /** Video Tracks */
            video_tracks: number | null;
            /** Subtitle Tracks */
            subtitle_tracks: number | null;
            /** Time Added */
            time_added: string;
        };
        /** Items */
        Items: {
            /** Sha256 */
            sha256: string[];
        };
        /** ItemsMeta */
        ItemsMeta: {
            /** Sha256 */
            sha256: string[];
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** JobModel */
        JobModel: {
            /** Queue Id */
            queue_id: number;
            /**
             * Job Type
             * @enum {string}
             */
            job_type: "data_extraction" | "data_deletion" | "folder_rescan" | "folder_update";
            /** Index Db */
            index_db: string;
            /** Metadata */
            metadata?: string | null;
            /** Batch Size */
            batch_size?: number | null;
            /** Threshold */
            threshold?: number | null;
            /**
             * Running
             * @default false
             */
            running: boolean;
        };
        /** JobSettings */
        JobSettings: {
            /** Group Name */
            group_name: string;
            /** Inference Id */
            inference_id?: string | null;
            /** Default Batch Size */
            default_batch_size?: number | null;
            /** Default Threshold */
            default_threshold?: number | null;
        };
        /** LogRecord */
        LogRecord: {
            /** Id */
            id: number;
            /** Start Time */
            start_time: string;
            /** End Time */
            end_time: string;
            /** Items In Db */
            items_in_db: number;
            /** Type */
            type: string;
            /** Setter */
            setter: string;
            /** Threshold */
            threshold: number | null;
            /** Batch Size */
            batch_size: number;
            /** Image Files */
            image_files: number;
            /** Video Files */
            video_files: number;
            /** Other Files */
            other_files: number;
            /** Total Segments */
            total_segments: number;
            /** Errors */
            errors: number;
            /** Total Remaining */
            total_remaining: number;
            /** Data Load Time */
            data_load_time: number;
            /** Inference Time */
            inference_time: number;
            /** Failed */
            failed: number;
            /** Completed */
            completed: number;
        };
        /** Match */
        Match: {
            /**
             * Match
             * @description
             *     The match operations to apply. Match filters operate on key-value pairs representing
             *     the primitive attributes of items, files, and extracted data.
             *     For example, a match filter can be used to filter items
             *     based on their type, size, or the path of the file they are associated with.
             *
             */
            match: components["schemas"]["MatchOps"] | components["schemas"]["MatchAnd"] | components["schemas"]["MatchOr"] | components["schemas"]["MatchNot"];
        };
        /** MatchAnd */
        MatchAnd: {
            /** And  */
            and_: components["schemas"]["MatchOps"][];
        };
        /** MatchNot */
        MatchNot: {
            not_: components["schemas"]["MatchOps"];
        };
        /** MatchOps */
        MatchOps: {
            eq?: components["schemas"]["MatchValue"] | null;
            neq?: components["schemas"]["MatchValue"] | null;
            in_?: components["schemas"]["MatchValues"] | null;
            nin?: components["schemas"]["MatchValues"] | null;
            gt?: components["schemas"]["MatchValue"] | null;
            gte?: components["schemas"]["MatchValue"] | null;
            lt?: components["schemas"]["MatchValue"] | null;
            lte?: components["schemas"]["MatchValue"] | null;
            startswith?: components["schemas"]["MatchValues"] | null;
            not_startswith?: components["schemas"]["MatchValues"] | null;
            endswith?: components["schemas"]["MatchValues"] | null;
            not_endswith?: components["schemas"]["MatchValues"] | null;
            contains?: components["schemas"]["MatchValues"] | null;
            not_contains?: components["schemas"]["MatchValues"] | null;
        };
        /** MatchOr */
        MatchOr: {
            /** Or  */
            or_: components["schemas"]["MatchOps"][];
        };
        /** MatchPath */
        MatchPath: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default false
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default asc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default asc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Match Path
             * @description Match a query against file paths
             */
            match_path: components["schemas"]["MatchPathArgs"];
        };
        /** MatchPathArgs */
        MatchPathArgs: {
            /**
             * Match
             * @description The query to match against file paths
             */
            match: string;
            /**
             * Match on filenames Only
             * @default false
             */
            filename_only: boolean;
            /**
             * Allow raw FTS5 MATCH Syntax
             * @description If set to False, the query will be escaped before being passed to the FTS5 MATCH function
             * @default true
             */
            raw_fts5_match: boolean;
        };
        /** MatchTags */
        MatchTags: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default false
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default desc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default desc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            match_tags: components["schemas"]["TagsArgs"];
        };
        /** MatchText */
        MatchText: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default false
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default asc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default asc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Match Extracted Text
             * @description
             *     Match a query against text extracted from files or associated with them,
             *     including tags and OCR text
             *
             */
            match_text: components["schemas"]["MatchTextArgs"];
        };
        /** MatchTextArgs */
        MatchTextArgs: {
            /**
             * Match
             * @description The query to match against text
             */
            match: string;
            /**
             * Filter Only
             * @description
             *     Only filter out text based on the other criteria,
             *     without actually matching the query.
             *
             *     If set to True, the match field will be ignored.
             *     Order by, select_as, and row_n will also be ignored.
             *
             *     If set to False (default), and the match field is empty,
             *     this filter will be skipped entirely.
             *
             * @default false
             */
            filter_only: boolean;
            /**
             * Include text from these setters
             * @description
             *     Filter out text that is was not set by these setters.
             *     The setters are usually the names of the models that extracted or generated the text.
             *     For example, the OCR model, the Whisper STT model, the captioning model or the tagger model.
             *
             */
            setters?: string[];
            /**
             * Included languages
             * @description Filter out text that is not in these languages
             */
            languages?: string[];
            /**
             * Minimum Confidence for Language Detection
             * @description
             *     Filter out text that has a language confidence score below this threshold.
             *     Must be a value between 0 and 1.
             *     Language confidence scores are usually set by the model that extracted the text.
             *     For tagging models, it's always 1.
             *
             */
            min_language_confidence?: number | null;
            /**
             * Minimum Confidence for the text
             * @description
             *     Filter out text that has a confidence score below this threshold.
             *     Must be a value between 0 and 1.
             *     Confidence scores are usually set by the model that extracted the text.
             *
             */
            min_confidence?: number | null;
            /**
             * Allow raw FTS5 MATCH Syntax
             * @description If set to False, the query will be escaped before being passed to the FTS5 MATCH function
             * @default true
             */
            raw_fts5_match: boolean;
            /**
             * Minimum Length
             * @description Filter out text that is shorter than this. Inclusive.
             */
            min_length?: number | null;
            /**
             * Maximum Length
             * @description Filter out text that is longer than this. Inclusive.
             */
            max_length?: number | null;
            /**
             * Return matching text snippet
             * @description
             *     If set, the best matching text *snippet* will be included in the `extra` dict of each result under this key.
             *     Works with any type of query, but it's best used with text-* queries.
             *
             *     Otherwise, it's somewhat slow because of the contortions needed to get the best snippet per file.
             *
             */
            select_snippet_as?: string | null;
            /**
             * Maximum Snippet Length
             * @description The maximum length (in tokens) of the snippet returned by select_snippet_as
             * @default 30
             */
            s_max_len: number;
            /**
             * Snippet Ellipsis
             * @description The ellipsis to use when truncating the snippet
             * @default ...
             */
            s_ellipsis: string;
            /**
             * Snippet Start Tag
             * @description The tag to use at the beginning of the snippet
             * @default <b>
             */
            s_start_tag: string;
            /**
             * Snippet End Tag
             * @description The tag to use at the end of the snippet
             * @default </b>
             */
            s_end_tag: string;
        };
        /** MatchValue */
        MatchValue: {
            /** File Id */
            file_id?: number | null;
            /** Item Id */
            item_id?: number | null;
            /** Path */
            path?: string | null;
            /** Filename */
            filename?: string | null;
            /** Sha256 */
            sha256?: string | null;
            /** Last Modified */
            last_modified?: string | null;
            /** Type */
            type?: string | null;
            /** Size */
            size?: number | null;
            /** Width */
            width?: number | null;
            /** Height */
            height?: number | null;
            /** Duration */
            duration?: number | null;
            /** Time Added */
            time_added?: string | null;
            /** Md5 */
            md5?: string | null;
            /** Audio Tracks */
            audio_tracks?: number | null;
            /** Video Tracks */
            video_tracks?: number | null;
            /** Subtitle Tracks */
            subtitle_tracks?: number | null;
            /** Data Id */
            data_id?: number | null;
            /** Language */
            language?: string | null;
            /** Language Confidence */
            language_confidence?: number | null;
            /** Text */
            text?: string | null;
            /** Confidence */
            confidence?: number | null;
            /** Text Length */
            text_length?: number | null;
            /** Job Id */
            job_id?: number | null;
            /** Setter Id */
            setter_id?: number | null;
            /** Setter Name */
            setter_name?: string | null;
            /** Data Index */
            data_index?: number | null;
            /** Source Id */
            source_id?: number | null;
        };
        /** MatchValues */
        MatchValues: {
            /** File Id */
            file_id?: number | number[] | null;
            /** Item Id */
            item_id?: number | number[] | null;
            /** Path */
            path?: string | string[] | null;
            /** Filename */
            filename?: string | string[] | null;
            /** Sha256 */
            sha256?: string | string[] | null;
            /** Last Modified */
            last_modified?: string | string[] | null;
            /** Type */
            type?: string | string[] | null;
            /** Size */
            size?: number | number[] | null;
            /** Width */
            width?: number | number[] | null;
            /** Height */
            height?: number | number[] | null;
            /** Duration */
            duration?: number | number[] | null;
            /** Time Added */
            time_added?: string | string[] | null;
            /** Md5 */
            md5?: string | string[] | null;
            /** Audio Tracks */
            audio_tracks?: number | number[] | null;
            /** Video Tracks */
            video_tracks?: number | number[] | null;
            /** Subtitle Tracks */
            subtitle_tracks?: number | number[] | null;
            /** Data Id */
            data_id?: number | number[] | null;
            /** Language */
            language?: string | string[] | null;
            /** Language Confidence */
            language_confidence?: number | number[] | null;
            /** Text */
            text?: string | string[] | null;
            /** Confidence */
            confidence?: number | number[] | null;
            /** Text Length */
            text_length?: number | number[] | null;
            /** Job Id */
            job_id?: number | number[] | null;
            /** Setter Id */
            setter_id?: number | number[] | null;
            /** Setter Name */
            setter_name?: string | string[] | null;
            /** Data Index */
            data_index?: number | number[] | null;
            /** Source Id */
            source_id?: number | number[] | null;
        };
        /** MessageResult */
        MessageResult: {
            /** Message */
            message: string;
        };
        /** NotOperator */
        NotOperator: {
            /** Not  */
            not_: components["schemas"]["SimilarTo"] | components["schemas"]["InBookmarks"] | components["schemas"]["MatchPath"] | components["schemas"]["MatchText"] | components["schemas"]["SemanticTextSearch"] | components["schemas"]["SemanticImageSearch"] | components["schemas"]["MatchTags"] | components["schemas"]["HasDataFrom"] | components["schemas"]["HasUnprocessedData"] | components["schemas"]["Match"] | components["schemas"]["AndOperator"] | components["schemas"]["OrOperator"] | components["schemas"]["NotOperator"];
        };
        /** OpenResponse */
        OpenResponse: {
            /** Path */
            path: string;
            /** Message */
            message: string;
        };
        /** OrOperator */
        OrOperator: {
            /** Or  */
            or_: (components["schemas"]["SimilarTo"] | components["schemas"]["InBookmarks"] | components["schemas"]["MatchPath"] | components["schemas"]["MatchText"] | components["schemas"]["SemanticTextSearch"] | components["schemas"]["SemanticImageSearch"] | components["schemas"]["MatchTags"] | components["schemas"]["HasDataFrom"] | components["schemas"]["HasUnprocessedData"] | components["schemas"]["Match"] | components["schemas"]["AndOperator"] | components["schemas"]["OrOperator"] | components["schemas"]["NotOperator"])[];
        };
        /** OrderArgs */
        OrderArgs: {
            /**
             * Order By
             * @default last_modified
             */
            order_by: ("file_id" | "sha256" | "path" | "filename" | "last_modified") | ("item_id" | "sha256" | "md5" | "type" | "size" | "width" | "height" | "duration" | "time_added" | "audio_tracks" | "video_tracks" | "subtitle_tracks") | ("data_id" | "language" | "language_confidence" | "text" | "confidence" | "text_length" | "job_id" | "setter_id" | "setter_name" | "data_index" | "source_id");
            /** Order */
            order?: ("asc" | "desc") | null;
            /**
             * Order Priority
             * @description
             *     The priority of this order by field. If multiple fields are ordered by,
             *     the priority is used to determine the order they are applied in.
             *     The order in the list is used if the priority is the same.
             *
             * @default 0
             */
            priority: number;
        };
        /** PQLQuery */
        PQLQuery: {
            /** Query */
            query?: components["schemas"]["SimilarTo"] | components["schemas"]["InBookmarks"] | components["schemas"]["MatchPath"] | components["schemas"]["MatchText"] | components["schemas"]["SemanticTextSearch"] | components["schemas"]["SemanticImageSearch"] | components["schemas"]["MatchTags"] | components["schemas"]["HasDataFrom"] | components["schemas"]["HasUnprocessedData"] | components["schemas"]["Match"] | components["schemas"]["AndOperator"] | components["schemas"]["OrOperator"] | components["schemas"]["NotOperator"] | null;
            /**
             * Values to order results by
             * @description
             *     The order_args field is a list of { order_by: [field name], order: ["asc" or "desc"] }
             *     objects that define how the results should be ordered.
             *     Results can be ordered by multiple fields by adding multiple objects.
             *
             */
            order_by?: components["schemas"]["OrderArgs"][];
            /**
             * Data to return
             * @description
             *     The columns to return in the query.
             *     The default columns are sha256, path, last_modified, and type.
             *     Columns belonging to text can only be selected if the entity is "text".
             *
             */
            select?: (("file_id" | "sha256" | "path" | "filename" | "last_modified") | ("item_id" | "sha256" | "md5" | "type" | "size" | "width" | "height" | "duration" | "time_added" | "audio_tracks" | "video_tracks" | "subtitle_tracks") | ("data_id" | "language" | "language_confidence" | "text" | "confidence" | "text_length" | "job_id" | "setter_id" | "setter_name" | "data_index" | "source_id"))[];
            /**
             * Target Entity
             * @description
             *     The entity to query on.
             *     You can perform the search on either files or text.
             *     This means that intermediate results will be one per file, or one per text-file pair.
             *     There are generally more text-file pairs than files, so this incurs overhead.
             *
             *     However, "text" queries allow you to include text-specific columns in the select list.
             *     The final results will also be one for each text-file pair.
             *
             *     Most of the same filters can be used on both.
             *     "text" queries will include "data_id" in each result. "file_id" and "item_id" are always included.
             *
             * @default file
             * @enum {string}
             */
            entity: "file" | "text";
            /**
             * Partition results By
             * @description
             *     Group results by the values of the specified column(s) and return the first result
             *     for each group according to all of the order settings of the query.
             *
             *     For example, if you partition by "item_id", you'll get one result per unique item.
             *     If you partition by "file_id", you'll get one result per unique file.
             *     Multiple columns yield one result for each unique combination of values for those columns.
             *
             *     You cannot partition by text columns if the entity is "file".
             *
             */
            partition_by?: (("file_id" | "sha256" | "path" | "filename" | "last_modified") | ("item_id" | "sha256" | "md5" | "type" | "size" | "width" | "height" | "duration" | "time_added" | "audio_tracks" | "video_tracks" | "subtitle_tracks") | ("data_id" | "language" | "language_confidence" | "text" | "confidence" | "text_length" | "job_id" | "setter_id" | "setter_name" | "data_index" | "source_id"))[] | null;
            /**
             * Page
             * @default 1
             */
            page: number;
            /**
             * Page Size
             * @default 10
             */
            page_size: number;
            /**
             * Count Results
             * @description
             *     If true, the query will return the total number of results that match the query.
             *     This is useful for pagination, but it requires an additional query to be executed.
             *
             * @default true
             */
            count: boolean;
            /**
             * Return Results
             * @description
             *     If true, the query will return the results that match the query.
             *     If false, only the total count will be returned, if requested.
             *
             * @default true
             */
            results: boolean;
            /**
             * Check Paths Exist
             * @description
             *     If true, the query will check if the path exists on disk before returning it.
             *
             *     For `file` queries with no partition by,
             *     the result will be omitted if the path does not exist.
             *     This is because if another file exists, it will be included later in the results.
             *
             *     In other cases, the system will try to find another file for the item and substitute it.
             *     If no other working path is found, the result will be omitted.
             *
             *     This is not reflected in the total count of results.
             *
             * @default false
             */
            check_path: boolean;
        };
        /** QueueCancelResponse */
        QueueCancelResponse: {
            /** Cancelled Jobs */
            cancelled_jobs: number[];
        };
        /** QueueStatusModel */
        QueueStatusModel: {
            /** Queue */
            queue: components["schemas"]["JobModel"][];
        };
        /** RRF */
        RRF: {
            /**
             * Smoothing Constant
             * @description
             *     The smoothing constant for the RRF function.
             *     The formula is: 1 / (rank + k).
             *
             *     Can be 0 for no smoothing.
             *
             *     Smoothing reduces the impact of "high" ranks (close to 1) on the final rank value.
             *
             * @default 1
             */
            k: number;
            /**
             * Weight
             * @description
             *     The weight to apply to this filter's rank value in the RRF function.
             *     The formula is: weight * 1 / (rank + k).
             *
             * @default 1
             */
            weight: number;
        };
        /** Results */
        Results: {
            /** Count */
            count: number;
            /** Results */
            results: components["schemas"]["FileSearchResult"][];
        };
        /** SearchResult */
        SearchResult: {
            /** File Id */
            file_id: number;
            /** Item Id */
            item_id: number;
            /** Path */
            path?: string | null;
            /** Filename */
            filename?: string | null;
            /** Sha256 */
            sha256?: string | null;
            /** Last Modified */
            last_modified?: string | null;
            /** Type */
            type?: string | null;
            /** Size */
            size?: number | null;
            /** Width */
            width?: number | null;
            /** Height */
            height?: number | null;
            /** Duration */
            duration?: number | null;
            /** Time Added */
            time_added?: string | null;
            /** Md5 */
            md5?: string | null;
            /** Audio Tracks */
            audio_tracks?: number | null;
            /** Video Tracks */
            video_tracks?: number | null;
            /** Subtitle Tracks */
            subtitle_tracks?: number | null;
            /** Data Id */
            data_id?: number | null;
            /** Language */
            language?: string | null;
            /** Language Confidence */
            language_confidence?: number | null;
            /** Text */
            text?: string | null;
            /** Confidence */
            confidence?: number | null;
            /** Text Length */
            text_length?: number | null;
            /** Job Id */
            job_id?: number | null;
            /** Setter Id */
            setter_id?: number | null;
            /** Setter Name */
            setter_name?: string | null;
            /** Data Index */
            data_index?: number | null;
            /** Source Id */
            source_id?: number | null;
            /**
             * Extra Fields
             * @description Extra fields retrieved from filters that are not part of the main result object.
             */
            extra?: {
                [key: string]: number | string | null;
            } | null;
        };
        /** SemanticImageArgs */
        SemanticImageArgs: {
            /**
             * Query
             * @description
             *     Semantic query to match against the image.
             *     Can be a string or a base64 encoded numpy array
             *     to supply an embedding directly.
             *
             */
            query: string;
            /**
             * The image embedding model to use
             * @description
             *     The image embedding model to use for the semantic search.
             *     Will search embeddings produced by this model.
             *
             */
            model: string;
            /**
             * Distance Aggregation
             * @description The method to aggregate distances when an item has multiple embeddings. Default is MIN.
             * @default MIN
             * @enum {string}
             */
            distance_aggregation: "MIN" | "MAX" | "AVG";
            /**
             * Embed The Query
             * @description
             *     Embed the query using the model already specified in `model`.
             *     This is useful when the query is a string and needs to be converted to an embedding.
             *
             *     If this is not present, the query is assumed to be an embedding already.
             *     In that case, it must be a base64 encoded string of a numpy array.
             *
             */
            embed?: components["schemas"]["EmbedArgs"];
            /**
             * Clip Xmodal
             * @description
             *     If true, will search among text embeddings as well as image embeddings created by the same CLIP model.
             *
             *     Note that you must have both image and text embeddings with the same CLIP model for this setting to work.
             *     Text embeddings are derived from text which must have been already previously produced by another model, such as an OCR model or a tagger.
             *     They are generated *separately* from the image embeddings, using a different job (Under 'CLIP Text Embeddings').
             *     Run a batch job with the same clip model for both image and text embeddings to use this setting.
             *
             * @default false
             */
            clip_xmodal: boolean;
            /** @description
             *     Filters and options to apply on source text.
             *     Can exclusively be used with `clip_xmodal` set to True.
             *     Otherwise, it will be ignored, as it only applies to text embeddings.
             *      */
            src_text?: components["schemas"]["SourceArgs"] | null;
        };
        /** SemanticImageSearch */
        SemanticImageSearch: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default true
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default asc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default asc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Search Image Embeddings
             * @description
             *     Search for image using semantic search on image embeddings.
             *
             */
            image_embeddings: components["schemas"]["SemanticImageArgs"];
        };
        /** SemanticTextArgs */
        SemanticTextArgs: {
            /**
             * Query
             * @description Semantic query to match against the text
             */
            query: string;
            /**
             * The text embedding model to use
             * @description
             *     The text embedding model to use for the semantic search.
             *     Will search embeddings produced by this model.
             *
             */
            model: string;
            /**
             * Distance Aggregation
             * @description The method to aggregate distances when an item has multiple embeddings. Default is MIN.
             * @default MIN
             * @enum {string}
             */
            distance_aggregation: "MIN" | "MAX" | "AVG";
            /**
             * Embed The Query
             * @description
             *     Embed the query using the model already specified in `model`.
             *     This is useful when the query is a string and needs to be converted to an embedding.
             *
             *     If this is not present, the query is assumed to be an embedding already.
             *     In that case, it must be a base64 encoded string of a numpy array.
             *
             */
            embed?: components["schemas"]["EmbedArgs"];
            /** @description
             *     Filters and options to apply on source text that the embeddings are derived from.
             *      */
            src_text?: components["schemas"]["SourceArgs"] | null;
        };
        /** SemanticTextSearch */
        SemanticTextSearch: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default true
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default asc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default asc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Search Text Embeddings
             * @description
             *     Search for text using semantic search on text embeddings.
             *
             */
            text_embeddings: components["schemas"]["SemanticTextArgs"];
        };
        /** SimilarTo */
        SimilarTo: {
            /**
             * Order by this filter's rank output
             * @description This filter generates a value that can be used for ordering.
             * @default true
             */
            order_by: boolean;
            /**
             * Order Direction
             * @description
             *     The order direction for this filter.
             *     If not set, the default order direction for this field is used.
             *
             * @default asc
             * @enum {string}
             */
            direction: "asc" | "desc";
            /**
             * Order By Priority
             * @description
             *     The priority of this filter in the order by clause.
             *     If there are multiple filters with order_by set to True,
             *     the priority is used to determine the order.
             *     If two filter order bys have the same priority,
             *     their values are coalesced into a single column to order by,
             *     and the order direction is determined by the first filter that we find from this set.
             *
             *     It's assumed that if the filters have the same priority, and should be coalesced,
             *     they will have the same order direction.
             *
             * @default 0
             */
            priority: number;
            /**
             * Use Row Number for rank column
             * @description
             *     Only applied if either order_by is True, or select_as is set.
             *
             *     If True, internally sorts the filter's output by its rank_order
             *     column and assigns a row number to each row.
             *
             *     The row number is used to order the final query.
             *
             *     This is useful for combining multiple filters with different
             *     rank_order types that may not be directly comparable,
             *     such as text search and embeddings search.
             *
             *     See `RRF` for a way to combine heterogeneous rank_order filters when using row_n = True.
             *
             * @default false
             */
            row_n: boolean;
            /**
             * Order Direction For Row Number
             * @description
             *     The order direction (asc or desc) for the internal row number calculation.
             *     Only used if `order_by_row_n` is True.
             *     When `order_by_row_n` is True, the filter's output is sorted by its rank_order column
             *     following this direction, and a row number is assigned to each row.
             *     This row number is used to order the final query.
             *     You should generally leave this as the default value.
             *
             * @default asc
             * @enum {string}
             */
            row_n_direction: "asc" | "desc";
            /**
             * Order By Greater Than
             * @description
             *     If set, only include items with an order_rank greater than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *     With cursor-based pagination, you should probably not rely on count = True anyhow.
             *
             */
            gt?: number | string | null;
            /**
             * Order By Less Than
             * @description
             *     If set, only include items with an order_rank less than this value.
             *     Can be used for cursor-based pagination.
             *     The type depends on the filter.
             *     Will be ignored in the count query, which is
             *     used to determine the total number of results when count = True.
             *
             */
            lt?: number | string | null;
            /**
             * Order By Select As
             * @description
             *     If set, the order_rank column will be returned with the results as this alias under the "extra" object.
             *
             */
            select_as?: string | null;
            /**
             * Reciprocal Ranked Fusion Parameters
             * @description
             *     Parameters for the Reciprocal Ranked Fusion.
             *     If set, when coalescing multiple filters with the same priority,
             *     the RRF function will be applied to the rank_order columns.
             *
             *     If only one filter has RRF set, but multiple filters have the same priority,
             *     RRF will be ignored.
             *
             *     If using RRF, you should set row_n to True for all the filters involved.
             *     Moreover, the correct direction for RRF is "desc" (higher is better).
             *
             */
            rrf?: components["schemas"]["RRF"] | null;
            /**
             * Item Similarity Search
             * @description
             *     Search for items similar to a target item using similarity search on embeddings.
             *     The search is based on the image or text embeddings of the provided item.
             *
             *     The setter name refers to the model that produced the embeddings.
             *     You can find a list of available values for this parameter using the /api/search/stats endpoint.
             *     Any setters of type "text-embedding" or "clip" can be used for this search.
             *
             *     "text" embeddings are derived from text produced by another model, such as an OCR model or a tagger.
             *     You can restrict the search to embeddings derived from text that was
             *     produced by one of a list of specific models by providing the appropriate filter.
             *     You can find a list of available values for text sources using the
             *     /api/search/stats endpoint, specifically any setter of type "text" will apply.
             *     Remember that tagging models also produce text by concatenating the tags,
             *      and are therefore also returned as "text" models by the stats endpoint.
             *     Restricting similarity to a tagger model or a set of tagger models
             *      is recommended for item similarity search based on text embeddings.
             *
             */
            similar_to: components["schemas"]["SimilarityArgs"];
        };
        /** SimilarityArgs */
        SimilarityArgs: {
            /**
             * Target
             * @description Sha256 hash of the target item to find similar items for
             */
            target: string;
            /**
             * Model
             * @description The name of the embedding model used for similarity search
             */
            model: string;
            /**
             * Distance Function
             * @description The distance function to use for similarity search. Default is L2.
             * @default L2
             * @enum {string}
             */
            distance_function: "L2" | "COSINE";
            /**
             * Distance Aggregation
             * @description The method to aggregate distances when an item has multiple embeddings. Default is AVG.
             * @default AVG
             * @enum {string}
             */
            distance_aggregation: "MIN" | "MAX" | "AVG";
            /** @description
             *     Filters and options to apply on source text.
             *     If not provided, all text embeddings are considered.
             *     The source text is the text which was used to produce the text embeddings.
             *      */
            src_text?: components["schemas"]["SourceArgs"] | null;
            /**
             * Clip Xmodal
             * @description
             *     Whether to use cross-modal similarity for CLIP models.
             *     Default is False. What this means is that the similarity is calculated between image and text embeddings,
             *     rather than just between image embeddings. By default will also use text-to-text similarity.
             *
             *     Note that you must have both image and text embeddings with the same CLIP model for this setting to work.
             *     Text embeddings are derived from text which must have been already previously produced by another model, such as an OCR model or a tagger.
             *     They are generated *separately* from the image embeddings, using a different job (Under 'CLIP Text Embeddings').
             *     Run a batch job with the same clip model for both image and text embeddings to use this setting.
             *
             * @default false
             */
            clip_xmodal: boolean;
            /**
             * Xmodal T2T
             * @description
             *     When using CLIP cross-modal similarity, whether to use text-to-text similarity as well or just image-to-text and image-to-image.
             *
             * @default true
             */
            xmodal_t2t: boolean;
            /**
             * Xmodal I2I
             * @description
             *     When using CLIP cross-modal similarity, whether to use image-to-image similarity as well or just image-to-text and text-to-text.
             *
             * @default true
             */
            xmodal_i2i: boolean;
        };
        /** SingleDBInfo */
        SingleDBInfo: {
            /** Current */
            current: string;
            /** All */
            all: string[];
        };
        /** SourceArgs */
        SourceArgs: {
            /**
             * Include text from these setters
             * @description
             *     Filter out text that is was not set by these setters.
             *     The setters are usually the names of the models that extracted or generated the text.
             *     For example, the OCR model, the Whisper STT model, the captioning model or the tagger model.
             *
             */
            setters?: string[];
            /**
             * Languages
             * @description
             *     The source languages to restrict the search to.
             *     These are the languages of the text produced by the source models.
             *
             */
            languages?: string[] | null;
            /**
             * Minimum Confidence for the text
             * @description
             *     Filter out text that has a confidence score below this threshold.
             *     Usually a value between 0 and 1.
             *     Confidence scores are usually set by the model that extracted the text.
             *
             */
            min_confidence?: number | null;
            /**
             * Min Language Confidence
             * @description
             *     Filter out text that has a language confidence score below this threshold.
             *     Usually a value between 0 and 1.
             *     Language confidence scores are usually set by the model that extracted the text.
             *     For tagging models, it's always 1.
             *
             * @default 0
             */
            min_language_confidence: number;
            /**
             * Min Length
             * @description Filter out text that is shorter than this. Inclusive.
             * @default 0
             */
            min_length: number;
            /**
             * Maximum Length
             * @description Filter out text that is longer than this. Inclusive.
             */
            max_length?: number | null;
            /**
             * Confidence Weight
             * @description
             *     The weight to apply to the confidence of the source text
             *     on the embedding distance aggregation for individual items with multiple embeddings.
             *     Default is 0.0, which means that the confidence of the source text
             *     does not affect the distance aggregation.
             *     This parameter is only relevant when the source text has a confidence value.
             *     The confidence of the source text is multiplied by the confidence of the other
             *     source text when calculating the distance between two items.
             *     The formula for the distance calculation is as follows:
             *     ```
             *     weights = POW(COALESCE(text.confidence, 1)), src_confidence_weight)
             *     distance = SUM(distance * weights) / SUM(weights)
             *     ```
             *     So this weight is the exponent to which the confidence is raised, which means that it can be greater than 1.
             *     When confidence weights are set, the distance_aggregation setting is ignored.
             *
             * @default 0
             */
            confidence_weight: number;
            /**
             * Language Confidence Weight
             * @description
             *     The weight to apply to the confidence of the source text language
             *     on the embedding distance aggregation.
             *     Default is 0.0, which means that the confidence of the source text language detection
             *     does not affect the distance calculation.
             *     Totally analogous to `src_confidence_weight`, but for the language confidence.
             *     When both are present, the results of the POW() functions for both are multiplied together before being applied to the distance.
             *     ```
             *     weights = POW(..., src_confidence_weight) * POW(..., src_language_confidence_weight)
             *     ```
             *
             * @default 0
             */
            language_confidence_weight: number;
        };
        /** StatusResponse */
        StatusResponse: {
            /** Status */
            status: string;
        };
        /** SystemConfig */
        SystemConfig: {
            /**
             * Remove Unavailable Files
             * @default true
             */
            remove_unavailable_files: boolean;
            /**
             * Scan Images
             * @default true
             */
            scan_images: boolean;
            /**
             * Scan Video
             * @default true
             */
            scan_video: boolean;
            /**
             * Scan Audio
             * @default false
             */
            scan_audio: boolean;
            /**
             * Scan Html
             * @default false
             */
            scan_html: boolean;
            /**
             * Scan Pdf
             * @default false
             */
            scan_pdf: boolean;
            /**
             * Enable Cron Job
             * @default false
             */
            enable_cron_job: boolean;
            /**
             * Cron Schedule
             * @default 0 3 * * *
             */
            cron_schedule: string;
            /** Job Settings */
            job_settings?: components["schemas"]["JobSettings"][];
        };
        /** TagFrequency */
        TagFrequency: {
            /** Tags */
            tags: [
                string,
                string,
                number,
                number
            ][];
        };
        /** TagResponse */
        TagResponse: {
            /** Tags */
            tags: [
                string,
                string,
                number,
                string
            ][];
        };
        /** TagSearchResults */
        TagSearchResults: {
            /** Tags */
            tags: [
                string,
                string,
                number
            ][];
        };
        /** TagStats */
        TagStats: {
            /** Namespaces */
            namespaces: string[];
            /** Min Confidence */
            min_confidence: number;
        };
        /** TagsArgs */
        TagsArgs: {
            /** List of tags to match */
            tags?: string[];
            /**
             * Match any tag
             * @description
             *     If true, match items with at least one of the given tags.
             *     If false (default), only match items with all of the given tags.
             *
             * @default false
             */
            match_any: boolean;
            /**
             * Minimum confidence
             * @description
             *     Only consider tags with a confidence greater than or equal to this value
             *
             * @default 0
             */
            min_confidence: number;
            /** Only consider tags set by these setters */
            setters?: string[];
            /** Only consider tags in these namespaces (includes sub-namespaces) */
            namespaces?: string[];
            /**
             * Require all setters to match
             * @description
             *     Only consider tags that have been set by all of the given setters.
             *     If match_any is true, and there is more than one tag, this will be ignored.
             *
             *     If you really want to match any tag set by all of the given setters,
             *     you can combine this with a separate filter for each tag in an OrOperator.
             *
             * @default false
             */
            all_setters_required: boolean;
        };
        /** TextResponse */
        TextResponse: {
            /** Text */
            text: components["schemas"]["ExtractedText"][];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_db_info_api_db_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DBInfo"];
                };
            };
        };
    };
    create_db_api_db_post: {
        parameters: {
            query?: {
                new_index_db?: string;
                new_user_data_db?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DBCreateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    open_file_on_host_api_open_file__sha256__post: {
        parameters: {
            query?: {
                path?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    show_in_file_manager_api_open_folder__sha256__post: {
        parameters: {
            query?: {
                path?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    pql_api_search_pql_post: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PQLQuery"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSearchResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_stats_api_search_stats_get: {
        parameters: {
            query?: {
                /** @description The bookmarks user to get the bookmark namespaces for */
                user?: string;
                /** @description Include namespaces from bookmarks with the * user value */
                include_wildcard?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APISearchStats"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_top_tags_api_search_tags_top_get: {
        parameters: {
            query?: {
                /** @description The tag namespace to search in */
                namespace?: string | null;
                /** @description The tag setter names to restrict the search to. Default is all */
                setters?: string[];
                /** @description The minimum confidence threshold for tags */
                confidence_threshold?: number | null;
                limit?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagFrequency"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_tags_api_search_tags_get: {
        parameters: {
            query: {
                /** @description The (partial) tag name to search for */
                name: string;
                limit?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagSearchResults"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_sha256_api_items_item__sha256__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_id_api_items_from_id__item_id__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                item_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_file_id_api_items_from_file_id__file_id__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                file_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_path_api_items_from_path__path__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_file_by_sha256_api_items_file__sha256__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Arbitrary binary data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    "*/*": unknown;
                };
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_thumbnail_by_sha256_api_items_thumbnail__sha256__get: {
        parameters: {
            query?: {
                big?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Image file binary */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    "*/*": unknown;
                };
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_text_by_sha256_api_items_text__sha256__get: {
        parameters: {
            query?: {
                setters?: string[];
                /** @description Text will be truncated to this length, if set. The `length` field will contain the original length. */
                truncate_length?: number | null;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TextResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_texts_by_text_ids_api_items_text_get: {
        parameters: {
            query: {
                /** @description List of extracted text IDs */
                text_ids: number[];
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TextResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_tags_by_sha256_api_items_tags__sha256__get: {
        parameters: {
            query?: {
                /** @description List of models that set the tags to filter by (default: all) */
                setters?: string[];
                /** @description List of namespaces to filter by (default: all). A namespace includes all namespaces that start with the namespace string. */
                namespaces?: string[];
                /** @description Minimum confidence threshold, between 0 and 1 (default: 0.0) */
                confidence_threshold?: number;
                /** @description Maximum number of tags to return for each *setter, namespace pair* (default: all). Higher confidence tags are given priority. */
                limit_per_namespace?: number | null;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_ns_list_api_bookmarks_ns_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkNamespaces"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_user_list_api_bookmarks_users_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkUsers"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmarks_by_namespace_api_bookmarks_ns__namespace__get: {
        parameters: {
            query?: {
                user?: string;
                page_size?: number;
                page?: number;
                order_by?: "last_modified" | "path" | "time_added";
                order?: ("asc" | "desc") | null;
                /** @description Whether or not to include bookmarks set under the wildcard user. */
                include_wildcard?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to get the bookmarks from. Wildcard ('*') results in getting bookmarks from all namespaces. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Results"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_bookmarks_by_sha256_api_bookmarks_ns__namespace__post: {
        parameters: {
            query?: {
                /** @description The user to save the bookmark under. The wildcard '*' can be used to set `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to save the bookmarks under. Wildcard is not allowed here. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ItemsMeta"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_bookmarks_by_namespace_api_bookmarks_ns__namespace__delete: {
        parameters: {
            query?: {
                /** @description The user to delete the bookmarks from. */
                user?: string;
                exclude_last_n?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to delete the bookmarks from. Wildcard ('*') results in deleting bookmarks from all namespaces. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Items"] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmark_api_bookmarks_ns__namespace___sha256__get: {
        parameters: {
            query?: {
                /** @description The user to get the bookmark from. The wildcard '*' can be used to get `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to get the bookmark from. Use '*' wildcard to mean 'any namespace', in which case it will return the first result found. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__put: {
        parameters: {
            query?: {
                /** @description The user to save the bookmark under. The wildcard '*' can be used to set `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to save the bookmark under. Wildcard is not allowed here. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": Record<string, never> | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__delete: {
        parameters: {
            query?: {
                /** @description The user to delete the bookmark from. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to delete the bookmark from. Wildcard ('*') results in deleting bookmarks for an item from all namespaces. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmarks_for_item_api_bookmarks_item__sha256__get: {
        parameters: {
            query?: {
                /** @description The user to get the bookmark from. The wildcard '*' can be used to get `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemBookmarks"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    predict_api_inference_predict__group___inference_id__post: {
        parameters: {
            query: {
                cache_key: string;
                lru_size: number;
                ttl_seconds: number;
            };
            header?: never;
            path: {
                group: string;
                inference_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_predict_api_inference_predict__group___inference_id__post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    load_model_api_inference_load__group___inference_id__put: {
        parameters: {
            query: {
                cache_key: string;
                lru_size: number;
                ttl_seconds: number;
            };
            header?: never;
            path: {
                group: string;
                inference_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unload_model_api_inference_cache__cache_key___group___inference_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                group: string;
                inference_id: string;
                cache_key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_cache_api_inference_cache__cache_key__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                cache_key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_cached_models_api_inference_cache_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CacheListResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_metadata_api_inference_metadata_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: Record<string, never>;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_queue_status_api_jobs_queue_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueueStatusModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cancel_queued_jobs_api_jobs_queue_delete: {
        parameters: {
            query: {
                queue_ids: number[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueueCancelResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    enqueue_data_extraction_job_api_jobs_data_extraction_post: {
        parameters: {
            query: {
                inference_ids: string[];
                batch_size?: number | null;
                threshold?: number | null;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobModel"][];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    enqueue_delete_extracted_data_api_jobs_data_extraction_delete: {
        parameters: {
            query: {
                inference_ids: string[];
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobModel"][];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    enqueue_folder_rescan_api_jobs_folders_rescan_post: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_folders_api_jobs_folders_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Folders"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    enqueue_update_folders_api_jobs_folders_put: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Folders"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_current_job_api_jobs_cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_scan_history_api_jobs_folders_history_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileScanRecord"][];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_extraction_history_api_jobs_data_history_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogRecord"][];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_config_api_jobs_config_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemConfig"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_config_api_jobs_config_put: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SystemConfig"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemConfig"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    search_search_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    scan_scan_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
