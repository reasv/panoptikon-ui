/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/db": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about all available databases
         * @description Get information about the database, including the names of all other available databases.
         *     Most API endpoints support specifying the databases to use for index and user data
         *     through the `index_db` and `user_data_db` query parameters.
         *     Regardless of which database is currently being used by panoptikon,
         *     the API allows you to perform actions and query data from any of the available databases.
         *     The current databases are simply the ones that are used by default.
         */
        get: operations["get_db_info_api_db_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/open/file/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Open a file in the default application
         * @description Open a file in the default application on the host system.
         *     This is done using os.startfile on Windows and xdg-open on Linux.
         *     This is a potentially dangerous operation, as it can execute arbitrary code.
         */
        post: operations["open_file_on_host_api_open_file__sha256__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/open/folder/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Show a file in the host system's file manager
         * @description Show a file in the host system's file manager.
         *     This is done using the appropriate command for the host system.
         *     On Windows, the file is highlighted in the Windows Explorer.
         *     On macOS, the file is revealed in the Finder.
         *     This is a potentially dangerous operation.
         */
        post: operations["show_in_file_manager_api_open_folder__sha256__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search for files in the database
         * @description Search for files in the database based on the provided query parameters.
         *
         *     The search query takes a `SearchQuery` object as input, which contains all the parameters supported by search.
         *     Search operates on `files`, which means that results are not unique by `sha256` value.
         *     The `count` returned in the response is the total number of unique files that match the query.
         *     There could be zero results even if the `count` is higher than zero,
         *     if the `page` parameter is set beyond the number of pages available.
         *
         *     For semantic search, embeddings should be provided as base64-encoded byte strings in npy format.
         *     To get the correct embeddings, use the /api/inference/predict endpoint with the correct inference_id.
         *
         *     It will return an application/octet-stream response with the embeddings in the correct format, which can be base64-encoded and used in the search query.
         *
         *     To get the list of embedding models the data is indexed with, use /api/search/stats and look for setters with "text-embedding" or "clip" type.
         */
        post: operations["search_api_search_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get statistics on the searchable data
         * @description Get statistics on the data indexed in the database.
         *     This includes information about the tag namespaces, bookmark namespaces, file types, and folders present.
         *     Most importantly, it includes the list of currently existing setters for each data type.
         *     This information is relevant for building search queries.
         */
        get: operations["get_stats_api_search_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/tags/top": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the most common tags in the database
         * @description Get the most common tags in the database, based on the provided query parameters.
         *     The result is a list of tuples, where each tuple contains the namespace, tag name,
         *     occurrences count, and relative frequency % (occurrences / total item_setter pairs).
         *     The latter value is expressed as a float between 0 and 1.
         *     The tags are returned in descending order of frequency.
         *     The `limit` parameter can be used to control the number of tags to return.
         *     The `namespace` parameter can be used to restrict the search to a specific tag namespace.
         *     The `setters` parameter can be used to restrict the search to specific setters.
         *     The `confidence_threshold` parameter can be used to filter tags based on the minimum confidence threshold.
         */
        get: operations["get_top_tags_api_search_tags_top_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search tag names for autocompletion
         * @description Given a string, finds tags whose names contain the string.
         *     Meant to be used for autocompletion in the search bar.
         *     The `limit` parameter can be used to control the number of tags to return.
         *     Returns a list of tuples, where each tuple contains the namespace, name,
         *     and the number of unique items tagged with the tag.
         *     The tags are returned in descending order of the number of items tagged.
         */
        get: operations["get_tags_api_search_tags_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/search/similar/{sha256}/{setter_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find similar items in the database
         * @description Find similar items in the database based on the provided SHA256 and setter name.
         *     The search is based on the image or text embeddings of the provided item.
         *
         *     The count value in the response is equal to the number of items returned, rather than the total number of similar items in the database.
         *     This is because there is no way to define what constitutes a "similar" item in a general sense. We just return the top N items that are most similar to the provided item.
         *
         *     The setter name refers to the model that produced the embeddings.
         *     You can find a list of available values for this parameter using the /api/search/stats endpoint.
         *     Any setters of type "text-embedding" or "clip" can be used for this search.
         *
         *     The `limit` parameter can be used to control the number of similar items to return.
         *
         *     "text" embeddings are derived from text produced by another model, such as an OCR model or a tagger.
         *     You can restrict the search to embeddings derived from text that was produced by one of a list of specific models by providing the `src_setter_names` parameter.
         *     You can find a list of available values for this parameter using the /api/search/stats endpoint, specifically any setter of type "text" will work.
         *     Remember that tagging models also produce text by concatenating the tags, and are therefore also returned as "text" models by the stats endpoint.
         *     Restricting similarity to a tagger model or a set of tagger models is recommended for item similarity search based on text embeddings.
         */
        get: operations["find_similar_api_search_similar__sha256___setter_name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/item/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from its sha256 hash
         * @description Returns metadata for a given item by its sha256 hash.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         *
         *     An `item` is a unique file. `item`s can have multiple `file`s associated with them, but unlike `file`s, `item`s have a unique sha256 hash.
         *     Files are unique by `path`. If all files associated with an `item` are deleted, the item is deleted.
         */
        get: operations["get_item_by_sha256_api_items_item__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/from-path/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get item metadata from a path
         * @description Returns metadata for a given item from its original file path.
         *     This includes the item metadata and a list of all files associated with the item.
         *     Files that do not exist on disk will not be included in the response.
         *     This means the file list may be empty.
         */
        get: operations["get_item_by_path_api_items_from_path__path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/file/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file by sha256
         * @description Returns the actual file contents for a given sha256 hash.
         *     Content type is determined by the file extension.
         */
        get: operations["get_file_by_sha256_api_items_file__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/thumbnail/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get thumbnail for an item by its sha256
         * @description Returns a thumbnail for a given item by its sha256 hash.
         *     The thumbnail may be a thumbnail,
         *     the unmodified original image (only for images),
         *     or a placeholder image generated on the fly.
         *     GIFs are always returned as the original file.
         *     For video thumbnails, the `big` parameter can be used to
         *     select between the 2x2 frame grid (big=True) or the first frame from the grid (big=False).
         */
        get: operations["get_thumbnail_by_sha256_api_items_thumbnail__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/text/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get text extracted from an item by its sha256
         * @description Returns the text extracted from a given item by its sha256 hash.
         */
        get: operations["get_text_by_sha256_api_items_text__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/items/tags/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tags for an item by its sha256
         * @description Returns the tags associated with a given item by its sha256 hash.
         *     The response contains a list of tuples, where each tuple contains
         *     the tag namespace, tag name, confidence, and setter name.
         *     The `setters` parameter can be used to filter tags by the setter name.
         *     The `confidence_threshold` parameter can be used to filter tags based on
         *     the minimum confidence threshold
         */
        get: operations["get_tags_by_sha256_api_items_tags__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all bookmark namespaces */
        get: operations["get_ns_list_api_bookmarks_ns_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all users with bookmarks */
        get: operations["get_user_list_api_bookmarks_users_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns/{namespace}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all bookmarks in a namespace
         * @description Get all items bookmarked in namespace.
         *     Note that unlike the search API, this returns unique items, not files.
         *     This has two implications:
         *     1. Results are unique by `sha256` value.
         *     2. Even if multiple files have the same `sha256` value, they will only appear once in the results, with the path of the first reachable file found.
         *
         *     The `order_by` parameter can be used to sort the results by `last_modified`, `path`, or `time_added`.
         *     The `order` parameter can be used to sort the results in ascending or descending order.
         *     The `include_wildcard` parameter can be used to include bookmarks with the `*` user value.
         */
        get: operations["get_bookmarks_by_namespace_api_bookmarks_ns__namespace__get"];
        put?: never;
        /**
         * Add multiple bookmarks to a namespace
         * @description Add multiple bookmarks to a namespace.
         *     The `sha256` values of the items to be bookmarked should be provided in the request body.
         *     Optionally, metadata can be provided.
         *     If metadata is provided, it should be a dictionary where the keys are the `sha256`
         *     values and the values are dictionaries of metadata.
         *     If the sha256 value is not in the metadata dictionary keys, the entire metadata dictionary
         *     will be used as metadata for the the sha256 item.
         *     You can use this to set the same metadata for all items.
         *
         *     Example request body:
         *     ```
         *     {
         *         "sha256": ["<sha256_1>", "<sha256_2>", ...],
         *         "metadata": {
         *             "<sha256_1>: {
         *                 "key1": "value1",
         *                 "key2": "value2",
         *                 ...
         *             },
         *             "key1": "value1",
         *             "key2": "value2",
         *             ...
         *         }
         *     }
         *     ```
         */
        post: operations["add_bookmarks_by_sha256_api_bookmarks_ns__namespace__post"];
        /**
         * Delete all/many bookmarks in a namespace
         * @description Delete all bookmarks in a namespace. If `exclude_last_n` is provided, the last `n` added bookmarks will be kept.
         *     Alternatively, a list of `sha256` values can be provided in the request body to only delete specific bookmarks.
         */
        delete: operations["delete_bookmarks_by_namespace_api_bookmarks_ns__namespace__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/ns/{namespace}/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a bookmark by namespace and sha256
         * @description Get a bookmark by namespace and sha256.
         *     Returns whether the bookmark exists and the metadata.
         */
        get: operations["get_bookmark_api_bookmarks_ns__namespace___sha256__get"];
        /**
         * Add a bookmark by namespace and sha256
         * @description Add a bookmark by namespace and sha256.
         *     Optionally, metadata can be provided as the request body.
         *     Metadata should be a dictionary of key-value pairs.
         */
        put: operations["add_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__put"];
        post?: never;
        /** Delete a specific bookmark by namespace and sha256 */
        delete: operations["delete_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/bookmarks/item/{sha256}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all bookmarks for an item
         * @description Get all bookmarks for an item.
         *     Returns a list of namespaces and metadata for each bookmark.
         */
        get: operations["get_bookmarks_for_item_api_bookmarks_item__sha256__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/predict/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run batch inference on a model by its `inference_id`
         * @description Runs batch inference on a model by its `inference_id` with the given inputs.
         *
         *     Before inference, the model is loaded using the specified `cache_key`, LRU size, and TTL (in seconds).
         *     This is identical to calling `PUT /load/{group}/{inference_id}`, see the documentation on that endpoint for more details.
         *
         *     Binary inputs are provided as multipart form data, structured inputs as JSON, the JSON string must be in the `data` form field.
         *     The JSON in the data field must be an object with an `inputs` key containing an array with the number of elements matching the size of the batch.
         *     Each element in the array can be a string, a dictionary, or null (in case that batch element only has binary input).
         *
         *     A batch consists of multiple inputs, each of which can be a binary file or a structured input or both.
         *     Binary files are mapped to the structured input by their filename which must be an index corresponding to the index of a structured input in the JSON array.
         *     The exact format depends on the specific model being used.
         *     The output can be either a JSON object containing an array under the key "outputs", a multipart/mixed response for binary data,
         *     or a single application/octet-stream for a single binary output.
         *
         *     Binary outputs are usually embeddings, which are provided in the npy format and can be loaded with numpy.load.
         *
         *     See `inferio.client` for an example of how to use this endpoint, which is non-trivial due to the multipart form data input and output.
         */
        post: operations["predict_api_inference_predict__group___inference_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/load/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Ensure a model is loaded into memory
         * @description Loads a model into memory with the specified `cache_key`, LRU size, and TTL (in seconds).
         *     As long as the model is present in at least one LRU cache, it will be kept in memory.
         *
         *     Models are evicted from an LRU in four cases:
         *
         *     - The LRU's size is exceeded when another load is attempted, causing the least recently used model(s) to be evicted
         *     - The model's TTL expires
         *     - The LRU is explicitly cleared by `cache_key` (see DELETE /cache/{cache_key})
         *     - The model is explicitly removed from the LRU (see DELETE /cache/{cache_key}/{group}/{inference_id})
         *
         *     The model will be loaded into memory only if it is not already loaded.
         *     If the model is already loaded, the cache key, LRU size, and TTL will be updated.
         *     The LRU size is overridden any time a load request is made, which may evict models from the LRU when it is resized.
         *
         *     A TTL of -1 means the model will never be unloaded due to TTL expiration. Other conditions still apply.
         */
        put: operations["load_model_api_inference_load__group___inference_id__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache/{cache_key}/{group}/{inference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unload a model from memory
         * @description Removes a model from the LRU cache `cache_key`.
         *     Once a model is removed from all caches, it will be unloaded from memory.
         */
        delete: operations["unload_model_api_inference_cache__cache_key___group___inference_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache/{cache_key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear the cache
         * @description Clears the LRU cache with key `cache_key`.
         *     If the models in it are not referenced by any other cache, they will be unloaded from memory.
         */
        delete: operations["clear_cache_api_inference_cache__cache_key__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/cache": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the list of loaded models
         * @description Returns a mapping of `inference_id`s for all loaded models to the lists of `cache_key`s that reference them.
         */
        get: operations["get_cached_models_api_inference_cache_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/inference/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a mapping of all available models and their metadata
         * @description Returns metadata for all available `inference_id`s, divided by group.
         */
        get: operations["get_metadata_api_inference_metadata_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Root */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search */
        get: operations["search_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** APISearchStats */
        APISearchStats: {
            /** Setters */
            setters: [
                "tags" | "text" | "clip" | "text-embedding",
                string
            ][];
            /** Bookmarks */
            bookmarks: string[];
            files: components["schemas"]["FileStats"];
            tags: components["schemas"]["TagStats"];
            /** Folders */
            folders: string[];
            text_stats: components["schemas"]["ExtractedTextStats"];
        };
        /** AnyTextFilter */
        AnyTextFilter: {
            path?: components["schemas"]["PathTextFilter"] | null;
            extracted_text?: components["schemas"]["ExtractedTextFilter"] | null;
        };
        /** Body_predict_api_inference_predict__group___inference_id__post */
        Body_predict_api_inference_predict__group___inference_id__post: {
            /**
             * Data
             * @description
             *     A JSON string containing the list of inputs to the batch prediction function, with the following structure:
             *     ```json
             *     {
             *         "inputs": [
             *             {"input2": "value"},
             *             null,
             *             ...
             *         ]
             *     }
             *     ```
             *     The array must have the same length as the number of inputs in the batch.
             *     This means that each file you include in the request must have a corresponding entry in the array.
             *     Entries can be JSON objects or null. For example, text embeddings expect objects with the following structure:
             *     ```json
             *     {
             *         "inputs": [
             *             {"text": "This is a sentence."},
             *             {"text": "Another sentence."},
             *             ...
             *         ]
             *     }
             *     ```
             *     For some models, the inputs can be null, in which case the corresponding file will be the only input.
             *
             *     Often, when not required, the input object will be used to pass optional inference-time parameters, such as "confidence" for confidence thresholds.
             *     In that case, null would result in default values being used.
             *
             *     Filenames for files in the files parameter must be integers starting from 0, representing the index in the batch, matching an element in the `inputs` array.
             *
             */
            data: string;
            /**
             * Files
             * @description
             *     A list of binary files to include in the batch prediction.
             *     Each file must have a filename that is an integer starting from 0, representing the index in the batch, matching an element in the `inputs` array in the `data` field.
             *     Files may be optional depending on the model, some do not operate on binary data.
             *
             * @default []
             */
            files: string[];
        };
        /** BookmarkMetadata */
        BookmarkMetadata: {
            /** Exists */
            exists: boolean;
            /** Namespace */
            namespace?: string | null;
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** BookmarkNamespaces */
        BookmarkNamespaces: {
            /** Namespaces */
            namespaces: string[];
        };
        /** BookmarkUsers */
        BookmarkUsers: {
            /** Users */
            users: string[];
        };
        /** BookmarksFilter */
        BookmarksFilter: {
            /**
             * Restrict To Bookmarks
             * @default true
             */
            restrict_to_bookmarks: boolean;
            /** Namespaces */
            namespaces?: string[];
            /**
             * User
             * @default user
             */
            user: string;
            /**
             * Include Wildcard
             * @default true
             */
            include_wildcard: boolean;
        };
        /** CacheListResponse */
        CacheListResponse: {
            /** Cache */
            cache: {
                [key: string]: string[];
            };
        };
        /** DBInfo */
        DBInfo: {
            index: components["schemas"]["SingleDBInfo"];
            user_data: components["schemas"]["SingleDBInfo"];
        };
        /** ExistingBookmarkMetadata */
        ExistingBookmarkMetadata: {
            /** Namespace */
            namespace?: string | null;
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** ExtractedText */
        ExtractedText: {
            /** Item Sha256 */
            item_sha256: string;
            /** Setter Name */
            setter_name: string;
            /** Language */
            language: string;
            /** Language Confidence */
            language_confidence: number | null;
            /** Text */
            text: string;
            /** Confidence */
            confidence: number | null;
            /** Length */
            length: number;
        };
        /** ExtractedTextEmbeddingsFilter */
        ExtractedTextEmbeddingsFilter: {
            /**
             * Query
             * Format: binary
             */
            query: string;
            /** Model */
            model: string;
            /** Targets */
            targets?: string[];
            /** Languages */
            languages?: string[];
            /** Language Min Confidence */
            language_min_confidence?: number | null;
            /** Min Confidence */
            min_confidence?: number | null;
        };
        /** ExtractedTextFilter */
        ExtractedTextFilter: {
            /** Query */
            query: string;
            /** Targets */
            targets?: string[];
            /** Languages */
            languages?: string[];
            /** Language Min Confidence */
            language_min_confidence?: number | null;
            /** Min Confidence */
            min_confidence?: number | null;
            /**
             * Raw Fts5 Match
             * @default true
             */
            raw_fts5_match: boolean;
        };
        /** ExtractedTextStats */
        ExtractedTextStats: {
            /** Lowest Confidence */
            lowest_confidence?: number | null;
            /** Lowest Language Confidence */
            lowest_language_confidence?: number | null;
            /** Languages */
            languages?: string[];
        };
        /** FileFilters */
        FileFilters: {
            /** Item Types */
            item_types?: string[];
            /** Include Path Prefixes */
            include_path_prefixes?: string[];
        };
        /** FileRecord */
        FileRecord: {
            /** Sha256 */
            sha256: string;
            /** Path */
            path: string;
            /** Last Modified */
            last_modified: string;
        };
        /** FileSearchResult */
        FileSearchResult: {
            /** Path */
            path: string;
            /** Sha256 */
            sha256: string;
            /** Last Modified */
            last_modified: string;
            /** Type */
            type: string;
        };
        /** FileSearchResultModel */
        FileSearchResultModel: {
            /** Count */
            count: number;
            /** Results */
            results: components["schemas"]["FileSearchResult"][];
        };
        /** FileStats */
        FileStats: {
            /** Total */
            total: number;
            /** Unique */
            unique: number;
            /** Mime Types */
            mime_types: string[];
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** ImageEmbeddingFilter */
        ImageEmbeddingFilter: {
            /**
             * Query
             * Format: binary
             */
            query: string;
            /** Model */
            model: string;
        };
        /** ItemBookmarks */
        ItemBookmarks: {
            /** Bookmarks */
            bookmarks: components["schemas"]["ExistingBookmarkMetadata"][];
        };
        /** ItemMetadata */
        ItemMetadata: {
            item: components["schemas"]["ItemRecord"];
            /** Files */
            files: components["schemas"]["FileRecord"][];
        };
        /** ItemRecord */
        ItemRecord: {
            /** Id */
            id: number;
            /** Sha256 */
            sha256: string;
            /** Md5 */
            md5: string;
            /** Type */
            type: string;
            /** Size */
            size: number | null;
            /** Width */
            width: number | null;
            /** Height */
            height: number | null;
            /** Duration */
            duration: number | null;
            /** Audio Tracks */
            audio_tracks: number | null;
            /** Video Tracks */
            video_tracks: number | null;
            /** Subtitle Tracks */
            subtitle_tracks: number | null;
            /** Time Added */
            time_added: string;
        };
        /** Items */
        Items: {
            /** Sha256 */
            sha256: string[];
        };
        /** ItemsMeta */
        ItemsMeta: {
            /** Sha256 */
            sha256: string[];
            /** Metadata */
            metadata?: Record<string, never> | null;
        };
        /** MessageResult */
        MessageResult: {
            /** Message */
            message: string;
        };
        /** OpenResponse */
        OpenResponse: {
            /** Path */
            path: string;
            /** Message */
            message: string;
        };
        /** OrderParams */
        OrderParams: {
            /**
             * Order By
             * @default last_modified
             */
            order_by: ("last_modified" | "path" | "rank_fts" | "rank_path_fts" | "time_added" | "rank_any_text" | "text_vec_distance" | "image_vec_distance") | null;
            /** Order */
            order?: ("asc" | "desc") | null;
            /**
             * Page
             * @default 1
             */
            page: number;
            /**
             * Page Size
             * @default 10
             */
            page_size: number;
        };
        /** PathTextFilter */
        PathTextFilter: {
            /** Query */
            query: string;
            /**
             * Only Match Filename
             * @default false
             */
            only_match_filename: boolean;
            /**
             * Raw Fts5 Match
             * @default true
             */
            raw_fts5_match: boolean;
        };
        /** QueryFilters */
        QueryFilters: {
            files?: components["schemas"]["FileFilters"] | null;
            path?: components["schemas"]["PathTextFilter"] | null;
            extracted_text?: components["schemas"]["ExtractedTextFilter"] | null;
            extracted_text_embeddings?: components["schemas"]["ExtractedTextEmbeddingsFilter"] | null;
            image_embeddings?: components["schemas"]["ImageEmbeddingFilter"] | null;
            any_text?: components["schemas"]["AnyTextFilter"] | null;
            bookmarks?: components["schemas"]["BookmarksFilter"] | null;
        };
        /** QueryParams */
        QueryParams: {
            tags?: components["schemas"]["QueryTagFilters"];
            filters?: components["schemas"]["QueryFilters"];
        };
        /** QueryTagFilters */
        QueryTagFilters: {
            /** Pos Match All */
            pos_match_all?: string[];
            /** Pos Match Any */
            pos_match_any?: string[];
            /** Neg Match Any */
            neg_match_any?: string[];
            /** Neg Match All */
            neg_match_all?: string[];
            /**
             * All Setters Required
             * @default false
             */
            all_setters_required: boolean;
            /** Setters */
            setters?: string[];
            /** Namespaces */
            namespaces?: string[];
            /** Min Confidence */
            min_confidence?: number | null;
        };
        /** Results */
        Results: {
            /** Count */
            count: number;
            /** Results */
            results: components["schemas"]["FileSearchResult"][];
        };
        /** SearchQuery */
        SearchQuery: {
            query?: components["schemas"]["QueryParams"];
            order_args?: components["schemas"]["OrderParams"];
            /**
             * Count
             * @default true
             */
            count: boolean;
            /**
             * Check Path
             * @default false
             */
            check_path: boolean;
        };
        /** SingleDBInfo */
        SingleDBInfo: {
            /** Current */
            current: string;
            /** All */
            all: string[];
        };
        /** StatusResponse */
        StatusResponse: {
            /** Status */
            status: string;
        };
        /** TagFrequency */
        TagFrequency: {
            /** Tags */
            tags: [
                string,
                string,
                number,
                number
            ][];
        };
        /** TagResponse */
        TagResponse: {
            /** Tags */
            tags: [
                string,
                string,
                number,
                string
            ][];
        };
        /** TagSearchResults */
        TagSearchResults: {
            /** Tags */
            tags: [
                string,
                string,
                number
            ][];
        };
        /** TagStats */
        TagStats: {
            /** Namespaces */
            namespaces: string[];
            /** Min Confidence */
            min_confidence: number;
        };
        /** TextResponse */
        TextResponse: {
            /** Text */
            text: components["schemas"]["ExtractedText"][];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_db_info_api_db_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DBInfo"];
                };
            };
        };
    };
    open_file_on_host_api_open_file__sha256__post: {
        parameters: {
            query?: {
                path?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    show_in_file_manager_api_open_folder__sha256__post: {
        parameters: {
            query?: {
                path?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    search_api_search_post: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SearchQuery"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSearchResultModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_stats_api_search_stats_get: {
        parameters: {
            query?: {
                /** @description The bookmarks user to get the bookmark namespaces for */
                user?: string;
                /** @description Include namespaces from bookmarks with the * user value */
                include_wildcard?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APISearchStats"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_top_tags_api_search_tags_top_get: {
        parameters: {
            query?: {
                /** @description The tag namespace to search in */
                namespace?: string | null;
                /** @description The tag setter names to restrict the search to. Default is all */
                setters?: string[];
                /** @description The minimum confidence threshold for tags */
                confidence_threshold?: number | null;
                limit?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagFrequency"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_tags_api_search_tags_get: {
        parameters: {
            query: {
                /** @description The (partial) tag name to search for */
                name: string;
                limit?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagSearchResults"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    find_similar_api_search_similar__sha256___setter_name__get: {
        parameters: {
            query?: {
                /** @description The source model names to restrict the search to. These are the models that produced the text for the items from which the text embeddings were produced. */
                src_setter_names?: string[] | null;
                limit?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
                /** @description The name of the embedding model use for similarity search */
                setter_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSearchResultModel"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_sha256_api_items_item__sha256__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_item_by_path_api_items_from_path__path__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_file_by_sha256_api_items_file__sha256__get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Arbitrary binary data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    "*/*": unknown;
                };
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_thumbnail_by_sha256_api_items_thumbnail__sha256__get: {
        parameters: {
            query?: {
                big?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Image file binary */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                    "*/*": unknown;
                };
            };
            /** @description Item not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_text_by_sha256_api_items_text__sha256__get: {
        parameters: {
            query?: {
                setters?: string[];
                /** @description Text will be truncated to this length, if set. The `length` field will contain the original length. */
                truncate_length?: number | null;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TextResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_tags_by_sha256_api_items_tags__sha256__get: {
        parameters: {
            query?: {
                /** @description List of models that set the tags to filter by (default: all) */
                setters?: string[];
                /** @description List of namespaces to filter by (default: all). A namespace includes all namespaces that start with the namespace string. */
                namespaces?: string[];
                /** @description Minimum confidence threshold, between 0 and 1 (default: 0.0) */
                confidence_threshold?: number;
                /** @description Maximum number of tags to return for each *setter, namespace pair* (default: all). Higher confidence tags are given priority. */
                limit_per_namespace?: number | null;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TagResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_ns_list_api_bookmarks_ns_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkNamespaces"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_user_list_api_bookmarks_users_get: {
        parameters: {
            query?: {
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkUsers"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmarks_by_namespace_api_bookmarks_ns__namespace__get: {
        parameters: {
            query?: {
                user?: string;
                page_size?: number;
                page?: number;
                order_by?: "last_modified" | "path" | "time_added";
                order?: ("asc" | "desc") | null;
                /** @description Whether or not to include bookmarks set under the wildcard user. */
                include_wildcard?: boolean;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to get the bookmarks from. Wildcard ('*') results in getting bookmarks from all namespaces. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Results"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_bookmarks_by_sha256_api_bookmarks_ns__namespace__post: {
        parameters: {
            query?: {
                /** @description The user to save the bookmark under. The wildcard '*' can be used to set `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to save the bookmarks under. Wildcard is not allowed here. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ItemsMeta"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_bookmarks_by_namespace_api_bookmarks_ns__namespace__delete: {
        parameters: {
            query?: {
                /** @description The user to delete the bookmarks from. */
                user?: string;
                exclude_last_n?: number;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to delete the bookmarks from. Wildcard ('*') results in deleting bookmarks from all namespaces. */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Items"] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmark_api_bookmarks_ns__namespace___sha256__get: {
        parameters: {
            query?: {
                /** @description The user to get the bookmark from. The wildcard '*' can be used to get `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to get the bookmark from. Use '*' wildcard to mean 'any namespace', in which case it will return the first result found. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookmarkMetadata"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__put: {
        parameters: {
            query?: {
                /** @description The user to save the bookmark under. The wildcard '*' can be used to set `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to save the bookmark under. Wildcard is not allowed here. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": Record<string, never> | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_bookmark_by_sha256_api_bookmarks_ns__namespace___sha256__delete: {
        parameters: {
            query?: {
                /** @description The user to delete the bookmark from. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                /** @description The namespace to delete the bookmark from. Wildcard ('*') results in deleting bookmarks for an item from all namespaces. */
                namespace: string;
                /** @description The sha256 of the item */
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MessageResult"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_bookmarks_for_item_api_bookmarks_item__sha256__get: {
        parameters: {
            query?: {
                /** @description The user to get the bookmark from. The wildcard '*' can be used to get `wildcard user` bookmarks that apply to all users. */
                user?: string;
                /** @description The name of the `index` database to open and use for this API call. Find available databases with `/api/db` */
                index_db?: string | null;
                /** @description The name of the `user_data` database to open and use for this API call. Find available databases with `/api/db` */
                user_data_db?: string | null;
            };
            header?: never;
            path: {
                sha256: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ItemBookmarks"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    predict_api_inference_predict__group___inference_id__post: {
        parameters: {
            query: {
                cache_key: string;
                lru_size: number;
                ttl_seconds: number;
            };
            header?: never;
            path: {
                group: string;
                inference_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_predict_api_inference_predict__group___inference_id__post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    load_model_api_inference_load__group___inference_id__put: {
        parameters: {
            query: {
                cache_key: string;
                lru_size: number;
                ttl_seconds: number;
            };
            header?: never;
            path: {
                group: string;
                inference_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unload_model_api_inference_cache__cache_key___group___inference_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                group: string;
                inference_id: string;
                cache_key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_cache_api_inference_cache__cache_key__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                cache_key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_cached_models_api_inference_cache_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CacheListResponse"];
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_metadata_api_inference_metadata_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: Record<string, never>;
                    };
                };
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    search_search_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
